#include "mesh_exporter.hpp"


#include <hadoken/format/format.hpp>

#include <morpho/morpho_h5_v1.hpp>

using namespace std;
namespace fmt = hadoken::format;


namespace morpho{

const std::string gmsh_header =
"/***************************************************************\n"
" * gmsh file generated by morpho-tool\n"
"****************************************************************/\n\n";

gmsh_exporter::gmsh_exporter(const std::string & morphology_filename, const std::string & mesh_filename, exporter_flags my_flags) :
    geo_stream(mesh_filename),
    reader(morphology_filename),
    flags(my_flags)
{


}


void gmsh_exporter::export_to_point_cloud(){
    serialize_header();
    serialize_points_raw();
}


void gmsh_exporter::export_to_wireframe(){
    serialize_header();


    int tree_flags = morpho::h5_v1::morpho_reader::generate_default;
    if(flags[exporter_single_soma]){
        tree_flags |= morpho::h5_v1::morpho_reader::generate_single_soma;
    }


    morpho_tree tree = reader.create_morpho_tree(static_cast<morpho::h5_v1::morpho_reader::generate_flags>(tree_flags));

    std::size_t n_branch = tree.get_tree_size();

    std::vector<std::pair<std::size_t, std::size_t>> range_vec;

    // export points for the soma first
    geo_stream << "// export morphology points \n";

    {
        size_t counter =0;
        range_vec.resize(n_branch);
        for(auto i = std::size_t(0); i < n_branch; ++i){
            range_vec[i]=
                        serialize_branch_points(tree.get_branch(i), counter);
        }
    }

    fmt::scat(geo_stream, "\n\n");

    {
        std::size_t point_counter=0, line_counter=0;

        serialize_branch_lines(tree,
                               0,
                               range_vec,
                               line_counter,
                               point_counter);

    }

}



void gmsh_exporter::serialize_header(){
    geo_stream << gmsh_header << "\n";


    fmt::scat(geo_stream,
              gmsh_header,
              "// converted to GEO format from ", reader.get_filename(), "\n");

}


std::pair<std::size_t, std::size_t> gmsh_exporter::serialize_branch_points(const branch &b, std::size_t & counter){
    auto& points = b.get_points();
    auto& distance = b.get_distances();

    assert(distance.size() == points.size1());

    fmt::scat(geo_stream,
              "// serialize points for branch ", b.get_id(), "\n");

    const size_t init_counter = counter;



    for(std::size_t i =0; i < points.size1(); ++i){

        fmt::scat(geo_stream,
                  "Point(", counter, ") = {", points(i,0), ",", points(i,1), ",", points(i,2), ",", distance(i), "} ;\n");
        counter++;

    }

    fmt::scat(geo_stream,
              "\n\n");
    // return last point id
    return std::make_pair(init_counter, counter);

}

void gmsh_exporter::serialize_branch_lines(morpho_tree & tree,
                                            size_t branch_id,
                                            const std::vector<std::pair<std::size_t, std::size_t> > & vec_range,
                                            size_t &counter, std::size_t & point_counter) {

    if(branch_id >= tree.get_tree_size()){
        return;
    }

    fmt::scat(geo_stream,
              "// serialize lines for branch ", branch_id, "\n");

    const auto & branch = tree.get_branch(branch_id);
    const auto & parent_branch = tree.get_branch(branch.get_parent_id());

    auto & points = branch.get_points();

    // we skip the first point, duplicate from last segment

    if(branch.get_type() == branch_type::soma && branch.get_points().size1() <= 1){
        fmt::scat(geo_stream, "// soma point mode, skip Line for soma\n");
    }else{
         point_counter = vec_range[branch_id].first;

         // if our parent is the soma
         // and we are in single soma mode
         // link to it
        if(parent_branch.get_type() == branch_type::soma && parent_branch.get_points().size1() == 1){
            fmt::scat(geo_stream,
                  "// link to parent soma \n"
                  "Line(", counter, ") = {", vec_range[parent_branch.get_id()].first, ",", point_counter, " } ;\n"
                      );
            counter += 1;
        }

        for(std::size_t i =0; i < points.size1()-1; ++i){

            fmt::scat(geo_stream,
                  "Line(", counter, ") = {", point_counter, ",", point_counter+1, " } ;\n"
                      );
            counter += 1;
            point_counter +=1;

        }
    }

    serialize_branch_lines(tree, branch_id+1, vec_range, counter, point_counter);
}


void gmsh_exporter::serialize_points_raw(){
    geo_stream << "// export morphology points \n";

    auto points = reader.get_points_raw();

    assert(points.size2() > 3);

    const std::size_t rows = points.size1();

    std::size_t id_point =0;

    for(std::size_t i =0; i < rows; ++i){
        fmt::scat(geo_stream,
                  "Point(", id_point, ") = {", points(i,0), ",", points(i,1), ",", points(i,2), ",", points(i,3), "} ;\n");
        id_point++;
    }

    geo_stream << "\n\n";
}


} // morpho
