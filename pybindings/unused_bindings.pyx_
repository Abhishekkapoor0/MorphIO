# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_morpho_mesher(_py__base):
#     "Python wrapper class for morpho_mesher (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef std.unique_ptr[morpho.morpho_mesher] _autodealoc
#     cdef morpho.morpho_mesher *ptr(self):
#         return <morpho.morpho_mesher*> self._ptr
#
#
#     def __init__(self, _py_morpho_tree tree, std.string output_mesh_file):
#         cdef std.shared_ptr[morpho.morpho_tree] tree_ptr
#         tree_ptr.reset(tree.ptr())
#         self._ptr = new morpho.morpho_mesher(tree_ptr, output_mesh_file)
#         self._autodealoc.reset(self.ptr())
#
#     def set_mesh_tag(self, int arg0, bool value):
#         return self.ptr().set_mesh_tag(<morpho_morpho_mesher.mesh_tag> arg0, value)
#
#     def set_error_bound(self, double inv_error):
#         return self.ptr().set_error_bound(inv_error)
#
#     def set_face_size(self, double face_size):
#         return self.ptr().set_face_size(face_size)
#
#     def execute(self, ):
#         return self.ptr().execute()
#
#     @staticmethod
#     cdef _py_morpho_mesher from_ptr(morpho.morpho_mesher *ptr):
#         cdef _py_morpho_mesher obj = _py_morpho_mesher.__new__(_py_morpho_mesher)
#         obj._ptr = ptr
#         obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_morpho_mesher from_ref(const morpho.morpho_mesher &ref):
#         return _py_morpho_mesher.from_ptr(<morpho.morpho_mesher*>&ref)
#
#     @staticmethod
#     cdef list vector2list( std.vector[morpho.morpho_mesher*] vec ):
#         return [ _py_morpho_mesher.from_ptr(elem) for elem in vec ]
#


# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_filter_duplicate_point_operation(_py__base):
#     "Python wrapper class for filter_duplicate_point_operation (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef std.unique_ptr[morpho.filter_duplicate_point_operation] _autodealoc
#     cdef morpho.filter_duplicate_point_operation *ptr(self):
#         return <morpho.filter_duplicate_point_operation*> self._ptr
#
#
#     def __init__(self, double min_distance):
#         self._ptr = new morpho.filter_duplicate_point_operation(min_distance)
#         self._autodealoc.reset(self.ptr())
#
#     @staticmethod
#     cdef _py_filter_duplicate_point_operation from_ptr(morpho.filter_duplicate_point_operation *ptr):
#         cdef _py_filter_duplicate_point_operation obj = _py_filter_duplicate_point_operation.__new__(_py_filter_duplicate_point_operation)
#         obj._ptr = ptr
#         obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_filter_duplicate_point_operation from_ref(const morpho.filter_duplicate_point_operation &ref):
#         return _py_filter_duplicate_point_operation.from_ptr(<morpho.filter_duplicate_point_operation*>&ref)
#
#     @staticmethod
#     cdef list vector2list( std.vector[morpho.filter_duplicate_point_operation*] vec ):
#         return [ _py_filter_duplicate_point_operation.from_ptr(elem) for elem in vec ]
#


# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_spatial_index(_py__base):
#     "Python wrapper class for spatial_index (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef std.unique_ptr[morpho.spatial_index] _autodealoc
#     cdef morpho.spatial_index *ptr(self):
#         return <morpho.spatial_index*> self._ptr
#
#
#     def __init__(self, ):
#         self._ptr = new morpho.spatial_index()
#         self._autodealoc.reset(self.ptr())
#
#     def add_morpho_tree(self, _py_morpho_tree tree):
#         cdef std.shared_ptr[morpho.morpho_tree] tree_ptr
#         tree_ptr.reset(tree.ptr())
#         return self.ptr().add_morpho_tree(tree_ptr)
#
#     #Error
#     # def is_within(self, int p):
#     #    return self.ptr().is_within(p)
#
#     @staticmethod
#     cdef _py_spatial_index from_ptr(morpho.spatial_index *ptr):
#         cdef _py_spatial_index obj = _py_spatial_index.__new__(_py_spatial_index)
#         obj._ptr = ptr
#         obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_spatial_index from_ref(const morpho.spatial_index &ref):
#         return _py_spatial_index.from_ptr(<morpho.spatial_index*>&ref)
#
#     @staticmethod
#     cdef list vector2list( std.vector[morpho.spatial_index*] vec ):
#         return [ _py_spatial_index.from_ptr(elem) for elem in vec ]
#



# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_morpho_operation(_py__base):
#     "Python wrapper class for morpho_operation (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef std.unique_ptr[morpho.morpho_operation] _autodealoc
#     cdef morpho.morpho_operation *ptr(self):
#         return <morpho.morpho_operation*> self._ptr
#
#
#     def apply(self, _py_morpho_tree morphology):
#         return _py_morpho_tree.from_ref(self.ptr().apply(deref(morphology.ptr())))
#
#     def name(self, ):
#         return self.ptr().name()
#
#     @staticmethod
#     cdef _py_morpho_operation from_ptr(morpho.morpho_operation *ptr):
#         cdef _py_morpho_operation obj = _py_morpho_operation.__new__(_py_morpho_operation)
#         obj._ptr = ptr
#         obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_morpho_operation from_ref(const morpho.morpho_operation &ref):
#         return _py_morpho_operation.from_ptr(<morpho.morpho_operation*>&ref)
#
#     @staticmethod
#     cdef list vector2list( std.vector[morpho.morpho_operation*] vec ):
#         return [ _py_morpho_operation.from_ptr(elem) for elem in vec ]
#
#
#
# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_morpho_operation_chain(_py__base):
#     "Python wrapper class for morpho_operation_chain (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef std.unique_ptr[morpho.morpho_operation_chain] _autodealoc
#     cdef morpho.morpho_operation_chain *ptr(self):
#         return <morpho.morpho_operation_chain*> self._ptr
#
#
#     def __init__(self, ):
#         self._ptr = new morpho.morpho_operation_chain()
#         self._autodealoc.reset(self.ptr())
#
#     def append(self, _py_morpho_operation new_operation):
#         return self.ptr().append(new_operation.ptr())
#
#     def get(self, std.size_t chain_elem):
#         return _py_morpho_operation.from_ref(self.ptr().get(chain_elem))
#
#     def size(self, ):
#         return self.ptr().size()
#
#     @staticmethod
#     cdef _py_morpho_operation_chain from_ptr(morpho.morpho_operation_chain *ptr):
#         cdef _py_morpho_operation_chain obj = _py_morpho_operation_chain.__new__(_py_morpho_operation_chain)
#         obj._ptr = ptr
#         obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_morpho_operation_chain from_ref(const morpho.morpho_operation_chain &ref):
#         return _py_morpho_operation_chain.from_ptr(<morpho.morpho_operation_chain*>&ref)
#
#     @staticmethod
#     cdef list vector2list( std.vector[morpho.morpho_operation_chain*] vec ):
#         return [ _py_morpho_operation_chain.from_ptr(elem) for elem in vec ]
#



# ======================================================================================================================
# Python bindings to namespace morpho::morpho_mesher
# ======================================================================================================================



