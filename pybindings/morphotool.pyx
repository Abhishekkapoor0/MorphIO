# -*- coding: utf-8 -*-
# =====================================================================================================================
# These bindings were automatically generated by cyWrap. Please do dot modify.
# Additional functionality shall be implemented in sub-classes.
#
__copyright__ = "Copyright 2016 EPFL BBP-project"
# =====================================================================================================================
from cython.operator cimport dereference as deref
from libcpp cimport bool
from libcpp.memory cimport unique_ptr
cimport std
include "_base.pxi"

cimport morpho
from .statics cimport morpho_morpho_mesher
from .statics cimport morpho_morpho_node_type
from .statics cimport morpho_neuron_struct_type
cimport morpho_h5_v1
from .statics cimport morpho_h5_v1_morpho_reader

import numpy as np
cimport numpy as np

# We need to initialize NumPy.
np.import_array()

## Include data structures
include "datastructs.pxi"


# ======================================================================================================================
# Python bindings to namespace 
# ======================================================================================================================



# ======================================================================================================================
# Python bindings to namespace morpho
# ======================================================================================================================



# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_morpho_mesher(_py__base):
#     "Python wrapper class for morpho_mesher (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef unique_ptr[morpho.morpho_mesher] _autodealoc
#     cdef morpho.morpho_mesher *ptr(self):
#         return <morpho.morpho_mesher*> self._ptr
#
#     def __init__(self, _py_morpho_tree tree, std.string output_mesh_file):
#         self._ptr = new morpho.morpho_mesher(tree._sharedPtr, output_mesh_file)
#         self._autodealoc.reset(self.ptr())
#
#     def set_mesh_tag(self, int arg0, bool value):
#         return self.ptr().set_mesh_tag(<morpho_morpho_mesher.mesh_tag> arg0, value)
#
#     def set_error_bound(self, double inv_error):
#         return self.ptr().set_error_bound(inv_error)
#
#     def set_face_size(self, double face_size):
#         return self.ptr().set_face_size(face_size)
#
#     def execute(self, ):
#         return self.ptr().execute()
#
#     @staticmethod
#     cdef _py_morpho_mesher from_ptr(morpho.morpho_mesher *ptr, bool owner=False):
#         cdef _py_morpho_mesher obj = _py_morpho_mesher.__new__(_py_morpho_mesher)
#         obj._ptr = ptr
#         if owner: obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_morpho_mesher from_ref(const morpho.morpho_mesher &ref):
#         return _py_morpho_mesher.from_ptr(<morpho.morpho_mesher*>&ref)
#
#     @staticmethod
#     cdef _py_morpho_mesher from_value(const morpho.morpho_mesher &ref):
#         cdef morpho.morpho_mesher *ptr = new morpho.morpho_mesher(ref)
#         return _py_morpho_mesher.from_ptr(ptr, True)
#
#     @staticmethod
#     cdef list vectorPtr2list(std.vector[morpho.morpho_mesher*] vec):
#         return [_py_morpho_mesher.from_ptr(elem) for elem in vec]
#
#     # morpho_mesher missing nullary ctor
#     # @staticmethod
#     # cdef list vector2list(std.vector[morpho.morpho_mesher] vec):
#     #     return [_py_morpho_mesher.from_value(elem) for elem in vec]
#



# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_delete_duplicate_point_operation(_py__base):
    "Python wrapper class for delete_duplicate_point_operation (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.delete_duplicate_point_operation] _autodealoc
    cdef morpho.delete_duplicate_point_operation *ptr(self):
        return <morpho.delete_duplicate_point_operation*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.delete_duplicate_point_operation()
        self._autodealoc.reset(self.ptr())

    def apply(self, _py_morpho_tree tree):
        return _py_morpho_tree.from_value(self.ptr().apply(deref(tree.ptr())))

    def name(self, ):
        return self.ptr().name()

    @staticmethod
    cdef _py_delete_duplicate_point_operation from_ptr(morpho.delete_duplicate_point_operation *ptr, bool owner=False):
        cdef _py_delete_duplicate_point_operation obj = _py_delete_duplicate_point_operation.__new__(_py_delete_duplicate_point_operation)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_delete_duplicate_point_operation from_ref(const morpho.delete_duplicate_point_operation &ref):
        return _py_delete_duplicate_point_operation.from_ptr(<morpho.delete_duplicate_point_operation*>&ref)

    @staticmethod
    cdef _py_delete_duplicate_point_operation from_value(const morpho.delete_duplicate_point_operation &ref):
        cdef morpho.delete_duplicate_point_operation *ptr = new morpho.delete_duplicate_point_operation(ref)
        return _py_delete_duplicate_point_operation.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.delete_duplicate_point_operation*] vec):
        return [_py_delete_duplicate_point_operation.from_ptr(elem) for elem in vec]

    @staticmethod
    cdef list vector2list(std.vector[morpho.delete_duplicate_point_operation] vec):
        return [_py_delete_duplicate_point_operation.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_duplicate_first_point_operation(_py__base):
    "Python wrapper class for duplicate_first_point_operation (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.duplicate_first_point_operation] _autodealoc
    cdef morpho.duplicate_first_point_operation *ptr(self):
        return <morpho.duplicate_first_point_operation*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.duplicate_first_point_operation()
        self._autodealoc.reset(self.ptr())

    def apply(self, _py_morpho_tree tree):
        return _py_morpho_tree.from_value(self.ptr().apply(deref(tree.ptr())))

    def name(self, ):
        return self.ptr().name()

    @staticmethod
    cdef _py_duplicate_first_point_operation from_ptr(morpho.duplicate_first_point_operation *ptr, bool owner=False):
        cdef _py_duplicate_first_point_operation obj = _py_duplicate_first_point_operation.__new__(_py_duplicate_first_point_operation)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_duplicate_first_point_operation from_ref(const morpho.duplicate_first_point_operation &ref):
        return _py_duplicate_first_point_operation.from_ptr(<morpho.duplicate_first_point_operation*>&ref)

    @staticmethod
    cdef _py_duplicate_first_point_operation from_value(const morpho.duplicate_first_point_operation &ref):
        cdef morpho.duplicate_first_point_operation *ptr = new morpho.duplicate_first_point_operation(ref)
        return _py_duplicate_first_point_operation.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.duplicate_first_point_operation*] vec):
        return [_py_duplicate_first_point_operation.from_ptr(elem) for elem in vec]

    @staticmethod
    cdef list vector2list(std.vector[morpho.duplicate_first_point_operation] vec):
        return [_py_duplicate_first_point_operation.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_spatial_index(_py__base):
    "Python wrapper class for spatial_index (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.spatial_index] _autodealoc
    cdef morpho.spatial_index *ptr(self):
        return <morpho.spatial_index*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.spatial_index()
        self._autodealoc.reset(self.ptr())

    def add_morpho_tree(self, _py_morpho_tree tree):
        return self.ptr().add_morpho_tree(tree._sharedPtr)

    def is_within(self, Point p):
        return self.ptr().is_within(deref(p.ptr()))

    @staticmethod
    cdef _py_spatial_index from_ptr(morpho.spatial_index *ptr, bool owner=False):
        cdef _py_spatial_index obj = _py_spatial_index.__new__(_py_spatial_index)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_spatial_index from_ref(const morpho.spatial_index &ref):
        return _py_spatial_index.from_ptr(<morpho.spatial_index*>&ref)

    # @staticmethod
    # cdef _py_spatial_index from_value(const morpho.spatial_index &ref):
    #     cdef morpho.spatial_index *ptr = new morpho.spatial_index(ref)
    #     return _py_spatial_index.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.spatial_index*] vec):
        return [_py_spatial_index.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.spatial_index] vec):
    #     return [_py_spatial_index.from_value(elem) for elem in vec]



# # ----------------------------------------------------------------------------------------------------------------------
# cdef class _py_morpho_operation(_py__base):
#     "Python wrapper class for morpho_operation (ns=morpho)"
# # ----------------------------------------------------------------------------------------------------------------------
#     cdef unique_ptr[morpho.morpho_operation] _autodealoc
#     cdef morpho.morpho_operation *ptr(self):
#         return <morpho.morpho_operation*> self._ptr
#
#
#     def __init__(self, ):
#         self._ptr = new morpho.morpho_operation()
#         self._autodealoc.reset(self.ptr())
#
#     def apply(self, _py_morpho_tree tree):
#         return _py_morpho_tree.from_value(self.ptr().apply(deref(tree.ptr())))
#
#     def name(self, ):
#         return self.ptr().name()
#
#     @staticmethod
#     cdef _py_morpho_operation from_ptr(morpho.morpho_operation *ptr, bool owner=False):
#         cdef _py_morpho_operation obj = _py_morpho_operation.__new__(_py_morpho_operation)
#         obj._ptr = ptr
#         if owner: obj._autodealoc.reset(obj.ptr())
#         return obj
#
#     @staticmethod
#     cdef _py_morpho_operation from_ref(const morpho.morpho_operation &ref):
#         return _py_morpho_operation.from_ptr(<morpho.morpho_operation*>&ref)
#
#     @staticmethod
#     cdef _py_morpho_operation from_value(const morpho.morpho_operation &ref):
#         cdef morpho.morpho_operation *ptr = new morpho.morpho_operation(ref)
#         return _py_morpho_operation.from_ptr(ptr, True)
#
#     @staticmethod
#     cdef list vectorPtr2list(std.vector[morpho.morpho_operation*] vec):
#         return [_py_morpho_operation.from_ptr(elem) for elem in vec]
#
#     @staticmethod
#     cdef list vector2list(std.vector[morpho.morpho_operation] vec):
#         return [_py_morpho_operation.from_value(elem) for elem in vec]
#
#


# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_morpho_node_type(_Enum):
    unknown = morpho_morpho_node_type.unknown
    neuron_node_3d_type = morpho_morpho_node_type.neuron_node_3d_type
    neuron_branch_type = morpho_morpho_node_type.neuron_branch_type
    neuron_soma_type = morpho_morpho_node_type.neuron_soma_type


# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_neuron_struct_type(_Enum):
    soma = morpho_neuron_struct_type.soma
    axon = morpho_neuron_struct_type.axon
    dentrite_basal = morpho_neuron_struct_type.dentrite_basal
    dentrite_apical = morpho_neuron_struct_type.dentrite_apical
    unknown = morpho_neuron_struct_type.unknown


# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_morpho_node(_py__base):
    "Python wrapper class for morpho_node (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.shared_ptr[morpho.morpho_node] _autodealoc
    cdef morpho.morpho_node *ptr(self):
        return <morpho.morpho_node*> self._ptr

    # def __init__(self, _py_morpho_node other = None):
    #     if other:
    #         self._ptr = new morpho.morpho_node(deref(other.ptr()))
    #     else:
    #         self._ptr = new morpho.morpho_node()
    #     self._autodealoc.reset(self.ptr())

    def get_bounding_box(self, ):
        return Box.from_value(self.ptr().get_bounding_box())

    def is_of_type(self, int mtype):
        return self.ptr().is_of_type(<morpho.morpho_node_type> mtype)

    @staticmethod
    cdef _py_morpho_node from_ptr(const morpho.morpho_node *ptr, bool owner=False):
        cdef _py_morpho_node obj = _py_morpho_node.__new__(_py_morpho_node)
        obj._ptr = <morpho.morpho_node*>ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_morpho_node from_ref(const morpho.morpho_node &ref):
        return _py_morpho_node.from_ptr(<morpho.morpho_node*>&ref)

    # @staticmethod
    # cdef _py_morpho_node from_value(const morpho.morpho_node &ref):
    #     cdef morpho.morpho_node *ptr = new morpho.morpho_node(ref)
    #     return _py_morpho_node.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[const morpho.morpho_node*] vec):
        return [_py_morpho_node.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.morpho_node] vec):
    #     return [_py_morpho_node.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_neuron_node_3d(_py__base):
    "Python wrapper class for neuron_node_3d (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.neuron_node_3d] _autodealoc
    cdef morpho.neuron_node_3d *ptr(self):
        return <morpho.neuron_node_3d*> self._ptr


    # def __init__(self, int my_node_type):
    #     self._ptr = new morpho.neuron_node_3d(<morpho.neuron_struct_type> my_node_type)
    #     self._autodealoc.reset(self.ptr())

    def get_branch_type(self, ):
        return <int>self.ptr().get_branch_type()

    def is_of_type(self, int mtype):
        return self.ptr().is_of_type(<morpho.morpho_node_type> mtype)

    @staticmethod
    cdef _py_neuron_node_3d from_ptr(morpho.neuron_node_3d *ptr, bool owner=False):
        cdef _py_neuron_node_3d obj = _py_neuron_node_3d.__new__(_py_neuron_node_3d)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_neuron_node_3d from_ref(const morpho.neuron_node_3d &ref):
        return _py_neuron_node_3d.from_ptr(<morpho.neuron_node_3d*>&ref)

    # @staticmethod
    # cdef _py_neuron_node_3d from_value(const morpho.neuron_node_3d &ref):
    #     cdef morpho.neuron_node_3d *ptr = new morpho.neuron_node_3d(ref)
    #     return _py_neuron_node_3d.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.neuron_node_3d*] vec):
        return [_py_neuron_node_3d.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.neuron_node_3d] vec):
    #     return [_py_neuron_node_3d.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_neuron_branch(_py__base):
    "Python wrapper class for neuron_branch (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.neuron_branch] _autodealoc
    cdef morpho.neuron_branch *ptr(self):
        return <morpho.neuron_branch*> self._ptr

    def __init__(self, int neuron_type, PointVector points, std.vector[double] radius):
        self._ptr = new morpho.neuron_branch(<morpho.neuron_struct_type> neuron_type, morpho.move_PointVector(deref(points.ptr())), morpho.move_DoubleVec(radius))
        self._autodealoc.reset(self.ptr())

    def __init__(self, _py_neuron_branch other):
        self._ptr = new morpho.neuron_branch(deref(other.ptr()))
        self._autodealoc.reset(self.ptr())

    def is_of_type(self, int mtype):
        return self.ptr().is_of_type(<morpho.morpho_node_type> mtype)

    def get_number_points(self, ):
        return self.ptr().get_number_points()

    def get_points(self, ):
        return PointVector.from_ref(self.ptr().get_points())

    def get_radius(self, ):
        return self.ptr().get_radius()

    def get_segment(self, size_t n):
        return Cone.from_value(self.ptr().get_segment(n))

    def get_bounding_box(self, ):
        return Box.from_value(self.ptr().get_bounding_box())

    def get_segment_bounding_box(self, size_t n):
        return Box.from_value(self.ptr().get_segment_bounding_box(n))

    def get_junction(self, size_t n):
        return Sphere.from_value(self.ptr().get_junction(n))

    def get_junction_sphere_bounding_box(self, size_t n):
        return Box.from_value(self.ptr().get_junction_sphere_bounding_box(n))

    def get_linestring(self, ):
        return Linestring.from_value(self.ptr().get_linestring())

    def get_circle_pipe(self, ):
        return CirclePipe.from_value(self.ptr().get_circle_pipe())

    @staticmethod
    cdef _py_neuron_branch from_ptr(morpho.neuron_branch *ptr, bool owner=False):
        cdef _py_neuron_branch obj = _py_neuron_branch.__new__(_py_neuron_branch)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_neuron_branch from_ref(const morpho.neuron_branch &ref):
        return _py_neuron_branch.from_ptr(<morpho.neuron_branch*>&ref)

    @staticmethod
    cdef _py_neuron_branch from_value(const morpho.neuron_branch &ref):
        cdef morpho.neuron_branch *ptr = new morpho.neuron_branch(ref)
        return _py_neuron_branch.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.neuron_branch*] vec):
        return [_py_neuron_branch.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.neuron_branch] vec):
    #     return [_py_neuron_branch.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_neuron_soma(_py__base):
    "Python wrapper class for neuron_soma (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho.neuron_soma] _autodealoc
    cdef morpho.neuron_soma *ptr(self):
        return <morpho.neuron_soma*> self._ptr

    # def __init__(self, list line_loop):
    #     #self._ptr = new morpho.neuron_soma(line_loop)
    #     #self._autodealoc.reset(self.ptr())

    def is_of_type(self, int mtype):
        return self.ptr().is_of_type(<morpho.morpho_node_type> mtype)

    def get_sphere(self, ):
        return Sphere.from_value(self.ptr().get_sphere())

    def get_bounding_box(self, ):
        return Box.from_value(self.ptr().get_bounding_box())

    def get_line_loop(self, ):
        return PointVector.from_ref(self.ptr().get_line_loop())

    @staticmethod
    cdef _py_neuron_soma from_ptr(morpho.neuron_soma *ptr, bool owner=False):
        cdef _py_neuron_soma obj = _py_neuron_soma.__new__(_py_neuron_soma)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_neuron_soma from_ref(const morpho.neuron_soma &ref):
        return _py_neuron_soma.from_ptr(<morpho.neuron_soma*>&ref)

    # @staticmethod
    # cdef _py_neuron_soma from_value(const morpho.neuron_soma &ref):
    #     cdef morpho.neuron_soma *ptr = new morpho.neuron_soma(ref)
    #     return _py_neuron_soma.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.neuron_soma*] vec):
        return [_py_neuron_soma.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.neuron_soma] vec):
    #     return [_py_neuron_soma.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_morpho_tree(_py__base):
    "Python wrapper class for morpho_tree (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.shared_ptr[morpho.morpho_tree] _sharedPtr
    cdef morpho.morpho_tree *ptr(self):
        return <morpho.morpho_tree*> self._ptr

    def __init__(self, ):
        self._ptr = new morpho.morpho_tree()
        self._sharedPtr.reset(self.ptr())

    def __init__(self, _py_morpho_tree other):
        self._ptr = new morpho.morpho_tree(deref(other.ptr()))
        self._sharedPtr.reset(self.ptr())

    def get_bounding_box(self, ):
        return Box.from_value(self.ptr().get_bounding_box())

    def get_tree_size(self, ):
        return self.ptr().get_tree_size()

    def swap(self, _py_morpho_tree other):
        return self.ptr().swap(deref(other.ptr()))

    def add_node(self, int parent_id, _py_morpho_node new_node):
        return self.ptr().add_node(parent_id, new_node._autodealoc)

    def copy_node(self, _py_morpho_tree other, int id_, int new_parent_id):
        return self.ptr().copy_node(deref(other.ptr()), id_, new_parent_id)

    def get_node(self, int id_):
        return _py_morpho_node.from_ref(self.ptr().get_node(id_))

    def get_parent(self, int id_):
        return self.ptr().get_parent(id_)

    def get_children(self, int id_):
        return self.ptr().get_children(id_)

    def get_all_nodes(self, ):
        return _py_morpho_node.vectorPtr2list(self.ptr().get_all_nodes())

    @staticmethod
    cdef _py_morpho_tree from_ptr(morpho.morpho_tree *ptr, bool owner=False):
        cdef _py_morpho_tree obj = _py_morpho_tree.__new__(_py_morpho_tree)
        obj._ptr = ptr
        if owner: obj._sharedPtr.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_morpho_tree from_ref(const morpho.morpho_tree &ref):
        return _py_morpho_tree.from_ptr(<morpho.morpho_tree*>&ref)

    @staticmethod
    cdef _py_morpho_tree from_value(const morpho.morpho_tree &ref):
        cdef morpho.morpho_tree *ptr = new morpho.morpho_tree(ref)
        return _py_morpho_tree.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho.morpho_tree*] vec):
        return [_py_morpho_tree.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho.morpho_tree] vec):
    #     return [_py_morpho_tree.from_value(elem) for elem in vec]





# ======================================================================================================================
# Python bindings to namespace morpho::h5_v1
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_morpho_reader(_py__base):
    "Python wrapper class for morpho_reader (ns=morpho::h5_v1)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho_h5_v1.morpho_reader] _autodealoc
    cdef morpho_h5_v1.morpho_reader *ptr(self):
        return <morpho_h5_v1.morpho_reader*> self._ptr


    def __init__(self, std.string filename):
        self._ptr = new morpho_h5_v1.morpho_reader(filename)
        self._autodealoc.reset(self.ptr())

    def get_points_raw(self, ):
        return Mat_Points.from_value(self.ptr().get_points_raw())

    def get_soma_points_raw(self, ):
        return Mat_Points.from_value(self.ptr().get_soma_points_raw())

    def get_struct_raw(self, ):
        return Mat_Index.from_value(self.ptr().get_struct_raw())

    def get_branch_range_raw(self, int id_):
        return self.ptr().get_branch_range_raw(id_)

    def get_filename(self, ):
        return self.ptr().get_filename()

    def create_morpho_tree(self, ):
        return _py_morpho_tree.from_value(self.ptr().create_morpho_tree())

    @staticmethod
    cdef _py_morpho_reader from_ptr(morpho_h5_v1.morpho_reader *ptr, bool owner=False):
        cdef _py_morpho_reader obj = _py_morpho_reader.__new__(_py_morpho_reader)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_morpho_reader from_ref(const morpho_h5_v1.morpho_reader &ref):
        return _py_morpho_reader.from_ptr(<morpho_h5_v1.morpho_reader*>&ref)

    @staticmethod
    cdef _py_morpho_reader from_value(const morpho_h5_v1.morpho_reader &ref):
        cdef morpho_h5_v1.morpho_reader *ptr = new morpho_h5_v1.morpho_reader(ref)
        return _py_morpho_reader.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho_h5_v1.morpho_reader*] vec):
        return [_py_morpho_reader.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho_h5_v1.morpho_reader] vec):
    #     return [_py_morpho_reader.from_value(elem) for elem in vec]




# ----------------------------------------------------------------------------------------------------------------------
cdef class _py_morpho_writer(_py__base):
    "Python wrapper class for morpho_writer (ns=morpho::h5_v1)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef unique_ptr[morpho_h5_v1.morpho_writer] _autodealoc
    cdef morpho_h5_v1.morpho_writer *ptr(self):
        return <morpho_h5_v1.morpho_writer*> self._ptr


    def __init__(self, std.string filename):
        self._ptr = new morpho_h5_v1.morpho_writer(filename)
        self._autodealoc.reset(self.ptr())

    def write(self, _py_morpho_tree tree):
        return self.ptr().write(deref(tree.ptr()))

    @staticmethod
    cdef _py_morpho_writer from_ptr(morpho_h5_v1.morpho_writer *ptr, bool owner=False):
        cdef _py_morpho_writer obj = _py_morpho_writer.__new__(_py_morpho_writer)
        obj._ptr = ptr
        if owner: obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef _py_morpho_writer from_ref(const morpho_h5_v1.morpho_writer &ref):
        return _py_morpho_writer.from_ptr(<morpho_h5_v1.morpho_writer*>&ref)

    @staticmethod
    cdef _py_morpho_writer from_value(const morpho_h5_v1.morpho_writer &ref):
        cdef morpho_h5_v1.morpho_writer *ptr = new morpho_h5_v1.morpho_writer(ref)
        return _py_morpho_writer.from_ptr(ptr, True)

    @staticmethod
    cdef list vectorPtr2list(std.vector[morpho_h5_v1.morpho_writer*] vec):
        return [_py_morpho_writer.from_ptr(elem) for elem in vec]

    # @staticmethod
    # cdef list vector2list(std.vector[morpho_h5_v1.morpho_writer] vec):
    #     return [_py_morpho_writer.from_value(elem) for elem in vec]


