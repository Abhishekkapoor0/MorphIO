# -*- coding: utf-8 -*-
# =====================================================================================================================
# These bindings were automatically generated by cyWrap. Please do dot modify.
# Additional functionality shall be implemented in sub-classes.
#
__copyright__ = "Copyright 2016 EPFL BBP-project"
# =====================================================================================================================
from cython.operator cimport dereference as deref
cimport std
from libcpp cimport bool

cimport morpho
from statics cimport morpho_morpho_mesher
cimport morpho_h5_v1
from statics cimport morpho_h5_v1_morpho_reader
import numpy as np
cimport numpy as np
cimport boost_numeric_ublas as ublas
from libc.string cimport memcpy


# We need to initialize NumPy.
np.import_array()

# --------------------- BASE CLASS ---------------------

cdef enum OPERATOR:
    LESS = 0, LESS_EQUAL, EQUAL, DIFF, GREATER, GREATER_EQUAL

cdef class _py__base:
    cdef void *_ptr
    # Basic comparison is done by comparing the inner obj ptr
    def __richcmp__(_py__base self, _py__base other, operation):
        if operation == OPERATOR.EQUAL:
            return self._ptr==other._ptr    


include "datastructs.pxi"


# ======================================================================================================================
# Python bindings to namespace morpho
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
cdef class Branch(_py__base):
    "Python wrapper class for branch (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.branch] _autodealoc
    cdef morpho.branch *ptr(self):
        return <morpho.branch*> self._ptr


    def __init__(self, int type_b):
        self._ptr = new morpho.branch(<morpho.branch_type> type_b)
        self._autodealoc.reset(self.ptr())

    #Error!
    #def set_points(self, _py_mat_points points, _py_vec_double distances):
    #    return self.ptr().set_points(deref(points.ptr()), deref(distances.ptr()))

    def get_points(self, ):
        # Memory shall stay valid, so no alloc
        cdef morpho.mat_points* matpoints = Mat_Points.ptr_from_ref(self.ptr().get_points())
        # Create a numpy array (memviews dont expose no nicely to python)
        cdef np.npy_intp[2] dim
        dim[0] = matpoints.size1()
        dim[1] = matpoints.size2()
        cdef np.ndarray[np.double_t, ndim=2] points = np.PyArray_SimpleNewFromData(2, dim, np.NPY_DOUBLE, matpoints.data().begin())
        return points

    #Testing purposes only
    def _change_point0(self):
        cdef morpho.mat_points * matpoints = Mat_Points.ptr_from_ref(self.ptr().get_points())
        cdef double * ptr = matpoints.data().begin()
        ptr[0] = 100010001

    # def get_distances(self, ):
    #     return Vec_Double.from_ref( self.ptr().get_distances() )

    def get_size(self, ):
        return self.ptr().get_size()

    #Point is unwrapped
    def get_point(self, std.size_t id_):
        # Point object is volatile,
        cdef morpho.point p = self.ptr().get_point(id_)
        # so we must create a python object which reserves memory
        cdef np.ndarray[np.double_t] arr = np.empty(3, "d")
        memcpy( arr.data, p.data(), 3*sizeof(double) )
        return arr

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    def get_segment(self, std.size_t n):
        return Cone.from_ref(self.ptr().get_segment(n))

    def get_segment_bounding_box(self, std.size_t n):
        return Box.from_ref(self.ptr().get_segment_bounding_box(n))

    def get_junction(self, std.size_t n):
        return Sphere.from_ref(self.ptr().get_junction(n))

    def get_junction_sphere_bounding_box(self, std.size_t n):
        return Box.from_ref(self.ptr().get_junction_sphere_bounding_box(n))

    def get_linestring(self, ):
        return Linestring.from_ref(self.ptr().get_linestring())

    # def get_circle_pipe(self, ):
    #     return self.ptr().get_circle_pipe()

    def get_childrens(self, ):
        return self.ptr().get_childrens()

    def get_parent(self, ):
        return self.ptr().get_parent()

    def get_id(self, ):
        return self.ptr().get_id()

    @staticmethod
    cdef Branch from_ptr(morpho.branch *ptr):
        cdef Branch obj = Branch.__new__(Branch)
        obj._ptr = ptr
        return obj
    
    @staticmethod
    cdef Branch from_ref(const morpho.branch &ref):
        return Branch.from_ptr(<morpho.branch*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho.branch*] vec ):
        return [ Branch.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class Branch_Soma(_py__base):
    "Python wrapper class for branch_soma (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.branch_soma] _autodealoc
    cdef morpho.branch_soma *ptr(self):
        return <morpho.branch_soma*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.branch_soma()
        self._autodealoc.reset(self.ptr())

    def get_sphere(self, ):
        return Sphere.from_ref(self.ptr().get_sphere())

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    @staticmethod
    cdef Branch_Soma from_ptr(morpho.branch_soma *ptr):
        cdef Branch_Soma obj = Branch_Soma.__new__(Branch_Soma)
        obj._ptr = ptr
        return obj
    
    @staticmethod
    cdef Branch_Soma from_ref(const morpho.branch_soma &ref):
        return Branch_Soma.from_ptr(<morpho.branch_soma*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho.branch_soma*] vec ):
        return [ Branch_Soma.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class Morpho_Tree(_py__base):
    "Python wrapper class for morpho_tree (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.morpho_tree] _autodealoc
    cdef morpho.morpho_tree *ptr(self):
        return <morpho.morpho_tree*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.morpho_tree()
        #self._autodealoc.reset(self.ptr())


    #def __init__(self, _py_morpho_tree other):
    #    self._ptr = new morpho.morpho_tree(deref(other.ptr()))
    #    self._autodealoc.reset(self.ptr())

    #Error
    # def set_root(self, Branch root_elem):
    #     cdef std.unique_ptr[morpho.branch] root_ptr
    #     root_ptr.reset(root_elem.ptr())
    #     return self.ptr().set_root(std.move(root_ptr))

    #Error
    # def add_child(self, std.size_t parent_id, Branch children):
    #     cdef std.unique_ptr[morpho.branch] child_ptr
    #     child_ptr.reset(children.ptr())
    #     return self.ptr().add_child(parent_id, std.move(child_ptr))


    def get_branch(self, std.size_t id_branch):
        return Branch.from_ref(self.ptr().get_branch(id_branch))

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    def get_tree_size(self, ):
        return self.ptr().get_tree_size()

    def add_flag(self, int flag):
        return self.ptr().add_flag(flag)

    def get_flags(self, ):
        return self.ptr().get_flags()

    @staticmethod
    cdef Morpho_Tree from_ptr(morpho.morpho_tree *ptr):
        cdef Morpho_Tree obj = Morpho_Tree.__new__(Morpho_Tree)
        obj._ptr = ptr
        return obj
    
    @staticmethod
    cdef Morpho_Tree from_ref(const morpho.morpho_tree &ref):
        return Morpho_Tree.from_ptr(<morpho.morpho_tree*>&ref)

    @staticmethod
    cdef Morpho_Tree from_move(morpho.morpho_tree &ref):
        cdef Morpho_Tree obj = Morpho_Tree()
        obj.ptr().swap(ref)
        return obj


    @staticmethod
    cdef list vector2list( std.vector[morpho.morpho_tree*] vec ):
        return [ Morpho_Tree.from_ptr(elem) for elem in vec ]


# ======================================================================================================================
# Python bindings to namespace morpho::h5_v1
# ======================================================================================================================

cdef class Morpho_Reader_Mat_Index(_py__base):
    cdef morpho_h5_v1_morpho_reader.mat_index* ptr(self):
        return <morpho_h5_v1_morpho_reader.mat_index *> self._ptr

    @staticmethod
    cdef Morpho_Reader_Mat_Index from_ptr(morpho_h5_v1_morpho_reader.mat_index *ptr):
        cdef Morpho_Reader_Mat_Index obj = Morpho_Reader_Mat_Index.__new__(Morpho_Reader_Mat_Index)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Morpho_Reader_Mat_Index from_ref(const morpho_h5_v1_morpho_reader.mat_index &ref):
        return Morpho_Reader_Mat_Index.from_ptr(<morpho_h5_v1_morpho_reader.mat_index*>&ref)


# ----------------------------------------------------------------------------------------------------------------------
cdef class Morpho_Reader(_py__base):
    "Python wrapper class for morpho_reader (ns=morpho::h5_v1)"
# ----------------------------------------------------------------------------------------------------------------------
    pass
    cdef std.unique_ptr[morpho_h5_v1.morpho_reader] _autodealoc
    cdef morpho_h5_v1.morpho_reader *ptr(self):
        return <morpho_h5_v1.morpho_reader*> self._ptr

    def __init__(self, std.string filename):
        self._ptr = new morpho_h5_v1.morpho_reader(filename)
        self._autodealoc.reset(self.ptr())

    def get_points_raw(self, ):
        return Mat_Points.from_ref(self.ptr().get_points_raw())

    def get_soma_points_raw(self, ):
        return Mat_Points.from_ref(self.ptr().get_soma_points_raw())

    def get_struct_raw(self, ):
        return Morpho_Reader_Mat_Index.from_ref(self.ptr().get_struct_raw())

    def get_branch_range_raw(self, int id_):
        return self.ptr().get_branch_range_raw(id_)

    def get_filename(self, ):
        return self.ptr().get_filename()

    def create_morpho_tree(self, ):
        cdef morpho.morpho_tree tree = self.ptr().create_morpho_tree()
        return Morpho_Tree.from_move(tree)

    @staticmethod
    cdef Morpho_Reader from_ptr(morpho_h5_v1.morpho_reader *ptr):
        cdef Morpho_Reader obj = Morpho_Reader.__new__(Morpho_Reader)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Morpho_Reader from_ref(const morpho_h5_v1.morpho_reader &ref):
        return Morpho_Reader.from_ptr(<morpho_h5_v1.morpho_reader*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho_h5_v1.morpho_reader*] vec ):
        return [ Morpho_Reader.from_ptr(elem) for elem in vec ]

