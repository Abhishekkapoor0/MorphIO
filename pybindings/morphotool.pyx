# -*- coding: utf-8 -*-
# =====================================================================================================================
# These bindings were automatically generated by cyWrap. Please do dot modify.
# Additional functionality shall be implemented in sub-classes.
#
__copyright__ = "Copyright 2016 EPFL BBP-project"
# =====================================================================================================================
from cython.operator cimport dereference as deref
cimport std
from libcpp cimport bool

cimport morpho
from statics cimport morpho_morpho_mesher
cimport morpho_h5_v1
from statics cimport morpho_h5_v1_morpho_reader
import numpy as np
cimport numpy as np
cimport boost_numeric_ublas as ublas
from libc.string cimport memcpy

# --------------------- BASE CLASS ---------------------

cdef enum OPERATOR:
    LESS = 0, LESS_EQUAL, EQUAL, DIFF, GREATER, GREATER_EQUAL

cdef class _py__base:
    cdef void *_ptr
    # Basic comparison is done by comparing the inner obj ptr
    def __richcmp__(_py__base self, _py__base other, operation):
        if operation == OPERATOR.EQUAL:
            return self._ptr==other._ptr    



# ======================================================================================================================
# Python bindings to namespace morpho
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
cdef class Box(_py__base):
    cdef morpho.box * ptr(self):
        return < morpho.box *> self._ptr

    @staticmethod
    cdef Box from_ptr(morpho.box *ptr):
        cdef Box obj = Box.__new__(Box)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Box from_ref(const morpho.box &ref):
        return Box.from_ptr(<morpho.box*>&ref)

# ----------------------------------------------------------------------------------------------------------------------
cdef class Point(_py__base):
    cdef morpho.point * ptr(self):
        return < morpho.point *> self._ptr

    @staticmethod
    cdef Point from_ptr(morpho.point *ptr):
        cdef Point obj = Point.__new__(Point)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Point from_ref(const morpho.point &ref):
        return Point.from_ptr(<morpho.point*>&ref)


# ----------------------------------------------------------------------------------------------------------------------
cdef class Vector(_py__base):
    cdef morpho.vector * ptr(self):
        return < morpho.vector *> self._ptr

    @staticmethod
    cdef Vector from_ptr(morpho.vector *ptr):
        cdef Vector obj = Vector.__new__(Vector)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Vector from_ref(const morpho.vector &ref):
        return Vector.from_ptr(<morpho.vector*>&ref)

# ----------------------------------------------------------------------------------------------------------------------
cdef class Linestring(_py__base):
    cdef morpho.linestring * ptr(self):
        return < morpho.linestring *> self._ptr

    @staticmethod
    cdef Linestring from_ptr(morpho.linestring *ptr):
        cdef Linestring obj = Linestring.__new__(Linestring)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Linestring from_ref(const morpho.linestring &ref):
        return Linestring.from_ptr(<morpho.linestring*>&ref)

# ----------------------------------------------------------------------------------------------------------------------
cdef class Cone(_py__base):
    cdef morpho.cone * ptr(self):
        return < morpho.cone *> self._ptr

    @staticmethod
    cdef Cone from_ptr(morpho.cone *ptr):
        cdef Cone obj = Cone.__new__(Cone)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Cone from_ref(const morpho.cone &ref):
        return Cone.from_ptr(<morpho.cone*>&ref)

# ----------------------------------------------------------------------------------------------------------------------
cdef class Sphere(_py__base):
    cdef morpho.sphere * ptr(self):
        return < morpho.sphere *> self._ptr

    @staticmethod
    cdef Sphere from_ptr(morpho.sphere *ptr):
        cdef Sphere obj = Sphere.__new__(Sphere)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Sphere from_ref(const morpho.sphere &ref):
        return Sphere.from_ptr(<morpho.sphere*>&ref)


# ----------------------------------------------------------------------------------------------------------------------
cdef class Morpho_Node(_py__base):
    "Python wrapper class for morpho_node (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.morpho_node] _autodealoc
    cdef morpho.morpho_node *ptr(self):
        return <morpho.morpho_node*> self._ptr


    def __init__(self, int my_node_type):
        self._ptr = new morpho.morpho_node(<morpho.branch_type> my_node_type)
        self._autodealoc.reset(self.ptr())

    def get_type(self, ):
        return self.ptr().get_type()

    @staticmethod
    cdef Morpho_Node from_ptr(morpho.morpho_node *ptr):
        cdef Morpho_Node obj = Morpho_Node.__new__(Morpho_Node)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef Morpho_Node from_ref(const morpho.morpho_node &ref):
        return Morpho_Node.from_ptr(<morpho.morpho_node*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho.morpho_node*] vec ):
        return [ Morpho_Node.from_ptr(elem) for elem in vec ]



# Data Structures wrappers
cdef class Mat_Points(_py__base):
    cdef morpho.mat_points * ptr(self):
        return <morpho.mat_points *> self._ptr

    @staticmethod
    cdef Mat_Points from_ptr(morpho.mat_points * ptr):
        cdef Mat_Points obj = Mat_Points.__new__(Mat_Points)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Mat_Points from_ref(const morpho.mat_points &ref):
        return Mat_Points.from_ptr(<morpho.mat_points*>&ref)

    @staticmethod
    cdef morpho.mat_points* ptr_from_ref(const morpho.mat_points &ref):
        return <morpho.mat_points*>&ref


cdef class Vec_Double(_py__base):
    cdef morpho.vec_double* ptr(self):
        return <morpho.vec_double *> self._ptr

    @staticmethod
    cdef Vec_Double from_ptr(morpho.vec_double *ptr):
        cdef Vec_Double obj = Vec_Double.__new__(Vec_Double)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Vec_Double from_ref(const morpho.vec_double &ref):
        return Vec_Double.from_ptr(<morpho.vec_double*>&ref)




# ----------------------------------------------------------------------------------------------------------------------
cdef class Branch(_py__base):
    "Python wrapper class for branch (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.branch] _autodealoc
    cdef morpho.branch *ptr(self):
        return <morpho.branch*> self._ptr


    def __init__(self, int type_b):
        self._ptr = new morpho.branch(<morpho.branch_type> type_b)
        self._autodealoc.reset(self.ptr())

    #Error!
    #def set_points(self, _py_mat_points points, _py_vec_double distances):
    #    return self.ptr().set_points(deref(points.ptr()), deref(distances.ptr()))

    def get_points(self, ):
        # Memory shall stay valid, so no alloc
        cdef morpho.mat_points* matpoints = Mat_Points.ptr_from_ref(self.ptr().get_points())
        # Create a memviews and convert to numpy array (memviews dont expose no nicely to python)
        cdef double[:,:] points = <double[:matpoints.size1(),:matpoints.size2()]>matpoints.data().begin()
        return np.asarray(points)

    #Testing purposes only
    def _change_point0(self):
        cdef morpho.mat_points * matpoints = Mat_Points.ptr_from_ref(self.ptr().get_points())
        cdef double * ptr = matpoints.data().begin()
        ptr[0] = 100010001

    def get_distances(self, ):
        return Vec_Double.from_ref( self.ptr().get_distances() )

    def get_size(self, ):
        return self.ptr().get_size()

    #Point is unwrapped
    def get_point(self, std.size_t id_):
        # Point object is volatile,
        cdef morpho.point p = self.ptr().get_point(id_)
        # so we must create a python object which reserves memory
        cdef np.ndarray[np.double_t] arr = np.empty(3, "d")
        memcpy( arr.data, p.data(), 3*sizeof(double) )
        return arr

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    def get_segment(self, std.size_t n):
        return Cone.from_ref(self.ptr().get_segment(n))

    def get_segment_bounding_box(self, std.size_t n):
        return Box.from_ref(self.ptr().get_segment_bounding_box(n))

    def get_junction(self, std.size_t n):
        return Sphere.from_ref(self.ptr().get_junction(n))

    def get_junction_sphere_bounding_box(self, std.size_t n):
        return Box.from_ref(self.ptr().get_junction_sphere_bounding_box(n))

    def get_linestring(self, ):
        return Linestring.from_ref(self.ptr().get_linestring())

    # def get_circle_pipe(self, ):
    #     return self.ptr().get_circle_pipe()

    def get_childrens(self, ):
        return self.ptr().get_childrens()

    def get_parent(self, ):
        return self.ptr().get_parent()

    def get_id(self, ):
        return self.ptr().get_id()

    @staticmethod
    cdef Branch from_ptr(morpho.branch *ptr):
        cdef Branch obj = Branch.__new__(Branch)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef Branch from_ref(const morpho.branch &ref):
        return Branch.from_ptr(<morpho.branch*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho.branch*] vec ):
        return [ Branch.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class Branch_Soma(_py__base):
    "Python wrapper class for branch_soma (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.branch_soma] _autodealoc
    cdef morpho.branch_soma *ptr(self):
        return <morpho.branch_soma*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.branch_soma()
        self._autodealoc.reset(self.ptr())

    def get_sphere(self, ):
        return Sphere.from_ref(self.ptr().get_sphere())

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    @staticmethod
    cdef Branch_Soma from_ptr(morpho.branch_soma *ptr):
        cdef Branch_Soma obj = Branch_Soma.__new__(Branch_Soma)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef Branch_Soma from_ref(const morpho.branch_soma &ref):
        return Branch_Soma.from_ptr(<morpho.branch_soma*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho.branch_soma*] vec ):
        return [ Branch_Soma.from_ptr(elem) for elem in vec ]



# ----------------------------------------------------------------------------------------------------------------------
cdef class Morpho_Tree(_py__base):
    "Python wrapper class for morpho_tree (ns=morpho)"
# ----------------------------------------------------------------------------------------------------------------------
    cdef std.unique_ptr[morpho.morpho_tree] _autodealoc
    cdef morpho.morpho_tree *ptr(self):
        return <morpho.morpho_tree*> self._ptr


    def __init__(self, ):
        self._ptr = new morpho.morpho_tree()
        #self._autodealoc.reset(self.ptr())


    #def __init__(self, _py_morpho_tree other):
    #    self._ptr = new morpho.morpho_tree(deref(other.ptr()))
    #    self._autodealoc.reset(self.ptr())

    #Error
    # def set_root(self, Branch root_elem):
    #     cdef std.unique_ptr[morpho.branch] root_ptr
    #     root_ptr.reset(root_elem.ptr())
    #     return self.ptr().set_root(std.move(root_ptr))

    #Error
    # def add_child(self, std.size_t parent_id, Branch children):
    #     cdef std.unique_ptr[morpho.branch] child_ptr
    #     child_ptr.reset(children.ptr())
    #     return self.ptr().add_child(parent_id, std.move(child_ptr))


    def get_branch(self, std.size_t id_branch):
        return Branch.from_ref(self.ptr().get_branch(id_branch))

    def get_bounding_box(self, ):
        return Box.from_ref(self.ptr().get_bounding_box())

    def get_tree_size(self, ):
        return self.ptr().get_tree_size()

    def add_flag(self, int flag):
        return self.ptr().add_flag(flag)

    def get_flags(self, ):
        return self.ptr().get_flags()

    @staticmethod
    cdef Morpho_Tree from_ptr(morpho.morpho_tree *ptr):
        cdef Morpho_Tree obj = Morpho_Tree.__new__(Morpho_Tree)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj
    
    @staticmethod
    cdef Morpho_Tree from_ref(const morpho.morpho_tree &ref):
        return Morpho_Tree.from_ptr(<morpho.morpho_tree*>&ref)

    @staticmethod
    cdef Morpho_Tree from_move(morpho.morpho_tree &ref):
        cdef Morpho_Tree obj = Morpho_Tree()
        obj.ptr().swap(ref)
        return obj


    @staticmethod
    cdef list vector2list( std.vector[morpho.morpho_tree*] vec ):
        return [ Morpho_Tree.from_ptr(elem) for elem in vec ]


# ======================================================================================================================
# Python bindings to namespace morpho::h5_v1
# ======================================================================================================================

cdef class Morpho_Reader_Mat_Index(_py__base):
    cdef morpho_h5_v1_morpho_reader.mat_index* ptr(self):
        return <morpho_h5_v1_morpho_reader.mat_index *> self._ptr

    @staticmethod
    cdef Morpho_Reader_Mat_Index from_ptr(morpho_h5_v1_morpho_reader.mat_index *ptr):
        cdef Morpho_Reader_Mat_Index obj = Morpho_Reader_Mat_Index.__new__(Morpho_Reader_Mat_Index)
        obj._ptr = ptr
        return obj

    @staticmethod
    cdef Morpho_Reader_Mat_Index from_ref(const morpho_h5_v1_morpho_reader.mat_index &ref):
        return Morpho_Reader_Mat_Index.from_ptr(<morpho_h5_v1_morpho_reader.mat_index*>&ref)


# ----------------------------------------------------------------------------------------------------------------------
cdef class Morpho_Reader(_py__base):
    "Python wrapper class for morpho_reader (ns=morpho::h5_v1)"
# ----------------------------------------------------------------------------------------------------------------------
    pass
    cdef std.unique_ptr[morpho_h5_v1.morpho_reader] _autodealoc
    cdef morpho_h5_v1.morpho_reader *ptr(self):
        return <morpho_h5_v1.morpho_reader*> self._ptr

    def __init__(self, std.string filename):
        self._ptr = new morpho_h5_v1.morpho_reader(filename)
        self._autodealoc.reset(self.ptr())

    def get_points_raw(self, ):
        return Mat_Points.from_ref(self.ptr().get_points_raw())

    def get_soma_points_raw(self, ):
        return Mat_Points.from_ref(self.ptr().get_soma_points_raw())

    def get_struct_raw(self, ):
        return Morpho_Reader_Mat_Index.from_ref(self.ptr().get_struct_raw())

    def get_branch_range_raw(self, int id_):
        return self.ptr().get_branch_range_raw(id_)

    def get_filename(self, ):
        return self.ptr().get_filename()

    def create_morpho_tree(self, ):
        cdef morpho.morpho_tree tree = self.ptr().create_morpho_tree()
        return Morpho_Tree.from_move(tree)

    @staticmethod
    cdef Morpho_Reader from_ptr(morpho_h5_v1.morpho_reader *ptr):
        cdef Morpho_Reader obj = Morpho_Reader.__new__(Morpho_Reader)
        obj._ptr = ptr
        obj._autodealoc.reset(obj.ptr())
        return obj

    @staticmethod
    cdef Morpho_Reader from_ref(const morpho_h5_v1.morpho_reader &ref):
        return Morpho_Reader.from_ptr(<morpho_h5_v1.morpho_reader*>&ref)

    @staticmethod
    cdef list vector2list( std.vector[morpho_h5_v1.morpho_reader*] vec ):
        return [ Morpho_Reader.from_ptr(elem) for elem in vec ]

